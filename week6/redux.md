# 3.Redux 따라하기

## Redux

Redux는 React와 같은 JavaScript 프레임워크와 함께 일반적으로 사용되는 인기 있는 상태 관리 라이브러리이지만 모든 UI 라이브러리 또는 프레임워크와 함께 사용할 수 있습니다. 애플리케이션의 상태를 관리하기 위한 예측 가능한 상태 컨테이너를 제공하고 복잡하고 확장 가능하며 유지 관리 가능한 애플리케이션의 개발을 용이하게 합니다.

Redux의 주요 개념 및 기능:

1. Single Source of Truth: Redux에서 애플리케이션의 전체 상태는 "store"라는 단일 JavaScript 개체에 저장됩니다. 이를 통해 애플리케이션 상태에 대한 단일 정보 소스가 있으므로 데이터 흐름을 더 쉽게 이해하고 관리할 수 있습니다.
2. 불변 상태(Immutable State:): Redux의 상태는 불변이므로 직접 수정할 수 없습니다. 대신 상태를 변경하면 새 상태 객체가 생성됩니다. 불변성은 상태 관리, 디버깅 및 성능 최적화에 도움이 됩니다.
3. 액션(Actions): 액션은 애플리케이션에서 이벤트 또는 사용자 상호 작용을 설명하는 일반 JavaScript 개체입니다. 상태 변경을 트리거하기 위해 Redux 스토어로 발송됩니다. 작업에는 작업을 설명하고 선택적으로 추가 데이터를 포함하는 '유형' 속성이 포함됩니다.
4. 리듀서(Reducers): 리듀서는 현재 상태와 작업을 인수로 사용하고 작업을 기반으로 새 상태를 반환하는 순수 함수입니다. 작업에 대한 응답으로 애플리케이션의 상태를 업데이트하는 방법을 정의합니다. Redux의 리듀서는 불변성의 원칙을 따르며 기존 상태를 수정하는 대신 새로운 상태 객체를 생성합니다.
5. 스토어(Store): 스토어는 애플리케이션 상태를 보유하고, 상태에 액세스하는 메서드를 제공하고, 상태를 업데이트하기 위한 작업을 디스패치하고, 리스너 등록을 통해 상태 변경을 알릴 수 있습니다. 저장소는 Redux에서 제공하는 createStore 기능을 사용하여 생성됩니다.
6. Dispatching Actions: 액션은 dispatch 메서드를 사용하여 스토어로 발송됩니다. 저장소는 작업을 기반으로 새 상태를 생성하는 적절한 감속기로 작업을 전달합니다. 저장소에 등록된 모든 구성 요소는 상태 변경에 대한 알림을 받고 그에 따라 업데이트할 수 있습니다.
7. 선택기(Selectors): 선택기는 Redux 상태에서 파생된 데이터를 추출하고 계산하는 기능입니다. 특정 상태에 액세스하고 구성 요소에서 불필요한 다시 렌더링을 방지하는 편리한 방법을 제공합니다.
8. 미들웨어(Middleware): Redux 미들웨어는 리듀서에 도달하기 전에 작업을 가로채고 조작할 수 있습니다. 미들웨어 기능은 디스패치 프로세스에 적용되어 비동기 작업, 로깅 또는 캐싱과 같은 추가 기능을 활성화합니다.

Redux 사용의 이점:

1. 중앙화된 상태(Centralized State): Redux는 복잡한 애플리케이션에서 상태 관리를 단순화하는 예측 가능한 중앙 집중식 상태 컨테이너를 제공합니다. 단일 진실 소스를 사용하면 애플리케이션의 상태에 대해 추론하기가 더 쉬워집니다.
2. 예측 가능한 상태 변경(Predictable State Changes): Redux는 엄격한 단방향 데이터 흐름을 적용하여 상태 변경을 예측하고 추적할 수 있도록 합니다. 이는 디버깅을 단순화하고 일관된 애플리케이션 상태를 유지하는 데 도움이 됩니다.
3. 시간 여행 디버깅(Time Travel Debugging): Redux의 불변성과 예측 가능한 상태 변경은 시간 여행 디버깅과 같은 강력한 디버깅 기능을 가능하게 합니다. 개발자는 과거 작업 및 상태를 재생하고 검사할 수 있으므로 문제를 더 쉽게 진단하고 수정할 수 있습니다.
4. 생태계 및 커뮤니티(Ecosystem and Community): Redux에는 도구, 확장 및 커뮤니티 지원의 대규모 생태계가 있습니다. 인기 있는 UI 라이브러리와 잘 통합되며 개발자가 Redux를 효과적으로 활용하는 데 도움이 되는 많은 리소스와 모범 사례를 사용할 수 있습니다.
5. 확장성 및 유지 관리 가능성(Scalability and Maintainability): Redux는 애플리케이션 상태 관리에 대한 구조화된 접근 방식을 촉진하여 애플리케이션이 복잡해짐에 따라 애플리케이션을 쉽게 확장하고 유지 관리할 수 있도록 합니다. 구성 요소에서 상태 관리를 분리하면 모듈성과 재사용성이 향상됩니다.

Redux가 모든 애플리케이션에 항상 필요한 것은 아니라는 점에 유의하는 것이 중요합니다. 추가 복잡성이 발생하고 작거나 간단한 프로젝트에 과도할 수 있습니다. 애플리케이션의 특정 요구 사항과 복잡성을 평가하여 Redux가 적합한 선택인지 판단하세요.

## Reflect

Reflect 개체는 동적 개체 생성, 속성 액세스 및 메서드 호출과 같은 메타 프로그래밍 작업을 수행하기 위한 일련의 메서드를 제공하는 ECMAScript 6(ES6)에 도입된 내장 JavaScript 개체입니다. 이를 통해 개발자는 런타임에 개체 및 해당 속성을 조작하고 상호 작용할 수 있습니다.

Reflect 개체에는 일반적으로 개체 지향 구문을 사용하여 수행되는 일부 기본 작업의 기능을 미러링하는 정적 메서드가 포함되어 있습니다. 이러한 메서드는 개체 작업에 보다 일관되고 표준적인 방식을 제공하여 보다 동적이고 유연한 프로그래밍을 가능하게 합니다.

Reflect 개체의 주요 특징 및 기능:

1. Property Reflection: Reflect는 Reflect.get, Reflect.set 및 Reflect.has와 같은 개체 속성 작업을 위한 메서드를 제공합니다. 이러한 메서드를 사용하면 개체에 대한 속성의 존재를 동적으로 액세스, 설정 또는 확인할 수 있습니다. 서로 다른 유형의 개체에서 이러한 작업을 수행하기 위한 통합 구문을 제공합니다.
2. 함수 호출(Function Invocation): Reflect를 사용하면 Reflect.apply 메서드를 사용하여 동적으로 함수 또는 메서드를 호출할 수 있습니다. 대상 함수, 원하는 this 값 및 함수를 호출하기 위한 인수 배열을 사용합니다. 이 방법은 런타임에 동적으로 결정되어야 하는 함수 호출을 처리할 때 특히 유용합니다.
3. 객체 생성(Object Creation): Reflect.construct 메서드는 가변 개수의 인수로 생성자를 호출하여 동적 객체 생성을 가능하게 합니다. 이는 new 키워드를 사용하는 대신 사용할 수 있으며 클래스의 인스턴스를 만드는 데 더 큰 유연성을 제공합니다.
4. 속성 정의(Property Definition): Reflect는 Reflect.defineProperty 및 Reflect.deleteProperty와 같은 개체 속성을 정의하고 조작하기 위한 메서드를 제공합니다. 이러한 메서드를 사용하면 개체에 대한 속성을 프로그래밍 방식으로 정의하고 속성을 설정하거나 동적으로 속성을 제거할 수 있습니다.
5. 유형 검사(Type Checking): Reflect에는 Reflect.isExtensible, Reflect.isSealed 및 Reflect.isFrozen과 같은 유형 검사를 위한 메서드가 포함되어 있습니다. 이러한 메서드는 개체의 확장성, 봉인 상태 및 불변성에 대한 정보를 제공합니다.
6. Proxy Interaction: Reflect는 또 다른 ES6 기능인 프록시 개체와 원활하게 작동합니다. 프록시 개체를 사용하면 기본 개체 작업을 가로채고 사용자 지정할 수 있습니다. Reflect 메서드는 가로채는 작업에 대한 기본 동작을 제공하여 Proxy 개체를 보완합니다.

Reflect 사용의 이점 및 사용 사례:

1. 통합 구문(Unified Syntax): Reflect는 개체 관련 작업을 수행하기 위한 일관되고 통합된 구문을 제공합니다. 코드를 단순화하고 동적 개체 상호 작용의 동작에 대해 더 쉽게 추론할 수 있습니다.
2. 메타 프로그래밍(Meta-programming): Reflect는 개발자가 런타임에 개체와 해당 속성을 동적으로 조작할 수 있도록 하여 메타 프로그래밍을 용이하게 합니다. 동적 동작을 생성하거나 인터셉터를 구현하거나 개체 작업을 사용자 지정하는 강력한 방법을 제공합니다.
3. 향상된 코드 유지 관리성(Enhanced Code Maintainability): Reflect를 활용하면 코드를 보다 쉽게 ​​유지 관리할 수 있고 설명이 필요해집니다. Reflect 메서드는 개체 관련 작업을 수행하는 표준 방법을 제공하여 코드를 더 읽기 쉽게 만들고 유사한 기능의 사용자 정의 구현 필요성을 줄입니다.
4. Proxies와의 통합(Integration with Proxies): Reflect 메서드는 Proxy 개체와 원활하게 작동하도록 설계되었습니다. Reflect와 Proxy의 조합은 강력한 메타 프로그래밍 기능을 가능하게 하여 개발자가 개체 작업을 가로채고 사용자 지정하여 유효성 검사, 캐싱 또는 액세스 제어와 같은 기능을 구현할 수 있도록 합니다.

Reflect는 동적 개체 조작 또는 메타 프로그래밍이 필요한 고급 시나리오에서 주로 사용된다는 점에 유의해야 합니다. 일반 개체 및 속성 작업의 경우 일반 개체 구문 및 기본 제공 메서드는 일반적으로 충분하고 사용하기 더 간단합니다. Reflect는 코드 복잡성과 성능 측면에서 그 기능과 잠재적 트레이드오프를 이해하고 신중하게 사용해야 합니다.
